Dewarping
This code loads existing baseline/VG data, add in the new data, performing dewarping, and then add the dewarped data to the end of the logbook opened at the start of the code. 
% Note that the .mat file is a log book of all previous results, running this 
% code will add one extra line at the end of the .mat file showing the dewarped 
% result.

This section reads in the logbook in the format of a .mat file
clear % clear all existing data first

[logbook_file, logbook_path] = uigetfile({'*.mat'},'Select Logbook');
load([logbook_path,logbook_file])
msgbox('The log book has been successfully read.', 'Code update');

Load new IR data to be added into the logbook
This section reads in the IR image in the format of a .csv file, this could be either a baseline case or VG case
% note that the .csv is generated by FLIR, and it contains information of the temp readings as well as the test conditions at
% the time

[fn,pn] = uigetfile({'*.csv'},'Select new IR data to be added');
data = importfile([pn fn]); % reads in the temp data of the .csv file
params = importparams([pn fn]); % reads in the paramters from the .csv file
clear fn; clear pn;
msgbox('The IR image has been successfully read.', 'Code update');

This section rotates the IR image clockwise by 90 degrees
data = imrotate(data,-90); 

msgbox('The IR image has been successfully rotated.', 'Code update');

This section finds the edge and corners of the IR image
Enter the sensitivity in finding the boundary using the slider below 
Gmag = imgradient(data, 'prewitt'); % find the gradient of the IR data first
sensitivity = 3.07;
Gmag(Gmag < sensitivity) = 0; % to remove any noises, this gives a pretty good indication of the boundary
% this line needs calibration as it will affect the sensitivity in
% determining the corners 

Gmag = im2bw(Gmag); % this gives the binary image of the gradient graph, where the boundary is clearly shown. 
Gmag = imfill(Gmag, 'holes'); % Fill holes
Gmag = bwareaopen(Gmag, 100); % Remove small objects
imagesc(Gmag)
Image = Gmag;
The codes below find the corners of the data before dewarping
[I,J]=find(Image>max(Image(:))/2);
IJ=[J,I];
[~,idx]=min(IJ*[1 1; -1 -1; 1 -1; -1 1].');
corners=IJ(idx,:);
The code below shows the corner detection result
imagesc(data)
hold on;
plot(corners(:,1),corners(:,2),'+r')
hold off

Corner correction
This section creates the pop up window which asks for correction of corner coordinate in case the automatic process fails. 
To users: only enter a new coordinate in if the automatic process yields inaccurate results, otherwise press 'ok' without changing any default values in the pop up window. 
% Convert matrix values to strings for display
existingMatrixStr = cellstr(num2str(corners(:)));

% Prompt message for the user
promptMessage = {'Corner 1 x coordinate:', 'Corner 2 x coordinate:', ...
    'Corner 3 x coordinate:', 'Corner 4 x coordinate:', ...
    'Corner 1 y coordinate:', 'Corner 2 y coordinate:', ...
    'Corner 3 y coordinate:', 'Corner 4 y coordinate:'};

% Title of the input dialog window
dlgTitle = 'Corner Correction';

userInput = inputdlg(promptMessage, dlgTitle, [1 50; 1 50; 1 50; 1 50; ...
    1 50; 1 50; 1 50; 1 50], existingMatrixStr);

% Check if the user provided input or canceled the dialog
if isempty(userInput)
    disp('User canceled the input dialog.');
else
    % Convert user input to a numeric matrix
    newMatrix = str2double(userInput);
    
    % Reshape the input into a 4x2 matrix
    newMatrix = reshape(newMatrix, 4, 2);
    
    % Check if any values are NaN (indicating invalid input)
    if any(isnan(newMatrix(:)))
        disp('Invalid input. Please enter numeric values.');
    else
        % Display updated matrix
        disp('Updated Matrix:');
        disp(newMatrix);
    end
end
corners = newMatrix;
The code below shows the corner correction result
imagesc(data)
hold on;
plot(corners(:,1),corners(:,2),'+r')
hold off

This section creates the transformation needed for performing dewarping
The transformation model needs to be found first before passing on to do the actual dewarping 
fixedPoints = [0 0; 590 350; 0 350; 590 0]; % Edge cordinates of dewarped data, this determines the size of the image after dewarping
movingPoints = corners;
tform = fitgeotrans(movingPoints,fixedPoints, 'projective'); % finds the transformation needed
Cal_image = imwarp(Image, tform); % apply the transformation found to the original image
% these two lines are automated
[I,J]=find(Cal_image>max(Cal_image(:))/2);
IJ=[J,I];
[~,idx]=min(IJ*[1 1; -1 -1; 1 -1; -1 1].');
cal_cor=IJ(idx,:);
Dewarp Data
Cal_data = imwarp(data,tform);

% the new line is below
Cal_data = imcrop(Cal_data, [cal_cor(1, 1) cal_cor(1, 2) max(cal_cor(:, 1)) - min(cal_cor(:, 1)) max(cal_cor(:, 2)) - min(cal_cor(:, 2))]);
This code shows the image of dewarped data
figure
imagesc(Cal_data)

Update data in i row location (VG)
These codes update the data after performing dewarping
i = length(test_result) + 1; 
% this line determine which line will be updated and it's manual
test_result(i).Emmisivity = str2num(params(1));

Tamb = char(params(4,1));
Tamb = str2double(Tamb(1:4));
if isnan(Tamb) == 1
    Tamb = char(params(4,1));
    Tamb = str2double(Tamb(1:3));
    if isnan(Tamb) == 1
        Tamb = char(params(4,1));
        Tamb = str2double(Tamb(1:2));
    end
end
test_result(i).T_amb = Tamb;

Tref = char(params(2,1));
Tref = str2double(Tref(1:4));
if isnan(Tref) == 1
    Tref = char(params(2,1));
    Tref = str2double(Tref(1:3));
    if isnan(Tref) == 1
        Tref = char(params(2,1));
        Tref = str2double(Tref(1:2));
    end
end

% change the following entry based on the actual experiment
test_result(i).VG_cases = '9_h15A_12082025_AGAIN';
test_result(i).VG_Ver_Spacing_mm = 0;
test_result(i).VG_Hor_Spacing_mm = 0;
test_result(i).date = "12/08/2025";
test_result(i).speed = 3;
test_result(i).T_refl = Tref; % ambient temp of the test [didn't change the stuff below but I don't think it's helpful, just unsure]
test_result(i).RH = 50;
test_result(i).T_optics = 20;
test_result(i).Cal_Data=Cal_data;
test_result(i).IR_data=data;

This section updates the result into the log book file
Update Mat Files
save( "aligned_vortex_generator_logbook.mat","test_result")
